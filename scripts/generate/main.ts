
import prisma from '@/lib/prisma';
import { toCamelCase } from '@/utils/text/camelCase';
import fs from 'fs';
import path from 'path';

// Type asserted as any b/c we need to access any model
const prismaClient = prisma as any;

// In-memory store for generated static records
const generatedRecords: { [key: string]: any } = {};

const processFileData = async (fileName: string, data: any) => {
  const { modelName, staticRecordName, staticRecordKeyName } = data;

  // Ensure model exists on the prisma client
  if (!prismaClient[modelName]) {
    console.warn(`ðŸ’” Skipping ${fileName}: Model ${modelName} does not exist on Prisma Client`);
    return;
  }

  console.log(`ðŸ” Querying ${modelName}...`);
  const records = await prismaClient[modelName].findMany();
  console.log(`âœ… Found ${records.length} records in ${modelName}.`);

  if (records.length === 0) {
    console.warn(`âš ï¸ No records found for ${modelName}. Skipping file generation.`);
    return;
  }

  // Create static records
  const outputPath = path.join(__dirname, "..", "..", "configs", "staticRecords", fileName);
  const exportName = staticRecordName ? staticRecordName : path.basename(fileName, '.ts');
  const keyName = staticRecordKeyName ? staticRecordKeyName : 'name';

  const transformedRecords = records.reduce((acc: any, curr: any) => {
    if (curr[keyName]) {
      acc[toCamelCase(curr[keyName])] = curr.id;
    } else {
      console.warn(`âš ï¸ Record in ${modelName} with ID ${curr.id} is missing the key '${keyName}'. Skipping.`);
    }
    return acc;
  }, {});

  // Store generated records in memory for dependent files
  generatedRecords[exportName] = transformedRecords;

  const fileContent = `// This file is auto-generated by the Lumexia generation script.
// Do not edit this file manually.

export const ${exportName} = ${JSON.stringify(transformedRecords, null, 2)} as const;
`;

  // Ensure static records directory exists then write data
  fs.mkdirSync(path.dirname(outputPath), { recursive: true });
  fs.writeFileSync(outputPath, fileContent);
  console.log(`âœ… ${exportName} data written to ${outputPath}`);
};

const Main = async () => {
  console.log('ðŸ” Starting the static record generation process...');

  const dataDirPath = path.join(__dirname, '..', 'initialization', 'data');
  const dataFiles = fs.readdirSync(dataDirPath);
  console.log(`ðŸ“ Found data files: ${dataFiles.join(', ')}`);

  const filesToProcess: { fileName: string, data: any }[] = [];

  for (const fileName of dataFiles) {
    const filePath = path.join(dataDirPath, fileName);
    const { data } = require(filePath);
    // don't need to handle dependency logic since we are just querying
    // and not seeding. The relationships should already exist in the database.
    filesToProcess.push({ fileName, data });
  }

  for (const file of filesToProcess) {
    // ignore the dependency logic that was in the seed script,
    // as we are just reading existing data.
    await processFileData(file.fileName, file.data);
  }
};

Main()
  .catch((error) => {
    console.error('ðŸ’” An error occurred during static record generation:', error);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
    console.log('ðŸŽ‰ Static record generation process finished.');
  });
