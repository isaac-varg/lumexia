import prisma from '@/lib/prisma';
import { toCamelCase } from '@/utils/text/camelCase';
import fs from 'fs';
import path from 'path';

// Type asserted as any b/c we need to access any model
const prismaClient = prisma as any;

// In-memory store for generated static records
const generatedRecords: { [key: string]: any } = {};

const processFileData = async (fileName: string, data: any, isDependency: boolean) => {
  let { modelName, seed, staticRecordName, staticRecordKeyName, dependencies, dependencyIterator } = data;

  // If it's a dependency, resolve the seed data by injecting other generated records
  if (isDependency) {
    const dependencyData = (dependencies || []).reduce((acc: any, depName: string) => {
      if (!generatedRecords[depName]) {
        throw new Error(`ðŸ’” Unresolved dependency: ${depName} is required by ${fileName} but was not found.`);
      }
      acc[depName] = generatedRecords[depName];
      return acc;
    }, {});
    if (dependencyIterator) {
      if (!generatedRecords[dependencyIterator]) {
        throw new Error(`ðŸ’” Unresolved dependencyIterator: ${dependencyIterator} is required by ${fileName} but was not found.`);
      }
      const recordsToIterate = generatedRecords[dependencyIterator];
      const accumulatedSeeds: any[] = [];
      for (const key of Object.keys(recordsToIterate)) {
        const id = recordsToIterate[key];
        const result = seed({ key, id }, dependencyData);
        if (result) {
          accumulatedSeeds.push(...result);
        }
      }
      seed = accumulatedSeeds;
    } else {
      seed = seed(dependencyData);
    }
  }

  // Ensure model exists on the prisma client/postgresql database
  if (!prismaClient[modelName]) {
    console.warn(`ðŸ’” Skipping ${fileName}: Model ${modelName} does not exist on Prisma Client`);
    return;
  }

  // Ensure seed data exists
  if (!seed || !Array.isArray(seed)) {
    console.warn(`ðŸ’” Skipping ${fileName}: No seed array found`);
    return;
  }

  // Clear existing data
  await prismaClient[modelName].deleteMany({});
  console.log(`ðŸŒ±  Seeding ${modelName}...`);

  // Seed data
  const response = await prismaClient[modelName].createManyAndReturn({
    data: seed,
  });
  console.log(`âœ… Seeded ${response.length} records into ${modelName}.`);

  // Create static records
  const outputPath = path.join(__dirname, "..", "..", "configs", "staticRecords", fileName);
  const exportName = staticRecordName ? staticRecordName : path.basename(fileName, '.ts');
  const keyName = staticRecordKeyName ? staticRecordKeyName : 'name';
  const transformedRecords = response.reduce((acc: any, curr: any) => {
    acc[toCamelCase(curr[keyName])] = curr.id;
    return acc;
  }, {});

  // Store generated records in memory for dependent files
  generatedRecords[exportName] = transformedRecords;

  const fileContent = `// This file is auto-generated by the Lumexia Initialization script.
// Do not edit this file manually.

export const ${exportName} = ${JSON.stringify(transformedRecords, null, 2)} as const;
`;

  // Ensure static records directory exists then write data
  fs.mkdirSync(path.dirname(outputPath), { recursive: true });
  fs.writeFileSync(outputPath, fileContent);
  console.log(`âœ… ${exportName} data written to ${outputPath}`);
};

const Main = async () => {
  console.log('ðŸŒ± Starting the seed process...');

  // Get the data files
  const dataDirPath = path.join(__dirname, 'data');
  const dataFiles = fs.readdirSync(dataDirPath);
  console.log(`ðŸ“ Found data files: ${dataFiles.join(', ')}`);

  const dependentFiles: { fileName: string, data: any }[] = [];
  const regularFiles: { fileName: string, data: any }[] = [];

  // Separate files into regular and dependent
  for (const fileName of dataFiles) {
    const filePath = path.join(dataDirPath, fileName);
    const { data } = require(filePath);
    if (data.dependency) {
      dependentFiles.push({ fileName, data });
    } else {
      regularFiles.push({ fileName, data });
    }
  }

  console.log('ðŸŒ± Processing non-dependent files first...');
  for (const file of regularFiles) {
    await processFileData(file.fileName, file.data, false);
  }

  console.log('ðŸŒ± Processing dependent files...');
  for (const file of dependentFiles) {
    await processFileData(file.fileName, file.data, true);
  }
};

// Execute the main function
Main()
  .catch((error) => {
    console.error('ðŸ’” An error occurred during initialization:', error);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
    console.log('ðŸŽ‰ Initialization process finished.');
  });