import prisma from '@/lib/prisma';
import { toCamelCase } from '@/utils/text/camelCase';
import fs from 'fs';
import path from 'path';

// Type asserted as any b/c we need to access any model
const prismaClient = prisma as any;

// In-memory store for generated static records
const generatedRecords: { [key: string]: any } = {};

const processFileData = async (fileName: string, data: any, isDependency: boolean) => {
  let { modelName, seed, staticRecordName, staticRecordKeyName, dependencies, dependencyIterator } = data;

  // If it's a dependency, resolve the seed data by injecting other generated records
  if (isDependency) {
    const dependencyData = (dependencies || []).reduce((acc: any, depName: string) => {
      if (!generatedRecords[depName]) {
        throw new Error(`ðŸ’” Unresolved dependency: ${depName} is required by ${fileName} but was not found.`);
      }
      acc[depName] = generatedRecords[depName];
      return acc;
    }, {});
    if (dependencyIterator) {
      if (!generatedRecords[dependencyIterator]) {
        throw new Error(`ðŸ’” Unresolved dependencyIterator: ${dependencyIterator} is required by ${fileName} but was not found.`);
      }
      const recordsToIterate = generatedRecords[dependencyIterator];
      const accumulatedSeeds: any[] = [];
      for (const key of Object.keys(recordsToIterate)) {
        const id = recordsToIterate[key];
        const result = seed({ key, id }, dependencyData);
        if (result) {
          accumulatedSeeds.push(...result);
        }
      }
      seed = accumulatedSeeds;
    } else {
      seed = seed(dependencyData);
    }
  }

  // Ensure model exists on the prisma client/postgresql database
  if (!prismaClient[modelName]) {
    console.warn(`ðŸ’” Skipping ${fileName}: Model ${modelName} does not exist on Prisma Client`);
    return;
  }

  // Ensure seed data exists
  if (!seed || !Array.isArray(seed)) {
    console.warn(`ðŸ’” Skipping ${fileName}: No seed array found`);
    return;
  }

  // Clear existing data
  await prismaClient[modelName].deleteMany({});
  console.log(`ðŸŒ±  Seeding ${modelName}...`);

  // Seed data
  const response = await prismaClient[modelName].createManyAndReturn({
    data: seed,
  });
  console.log(`âœ… Seeded ${response.length} records into ${modelName}.`);

  // Create static records
  const outputPath = path.join(__dirname, "..", "..", "configs", "staticRecords", fileName);
  const exportName = staticRecordName ? staticRecordName : path.basename(fileName, '.ts');
  const keyName = staticRecordKeyName ? staticRecordKeyName : 'name';
  const transformedRecords = response.reduce((acc: any, curr: any) => {
    acc[toCamelCase(curr[keyName])] = curr.id;
    return acc;
  }, {});

  // Store generated records in memory for dependent files
  generatedRecords[exportName] = transformedRecords;

  const fileContent = `// This file is auto-generated by the Lumexia Initialization script.
// Do not edit this file manually.

export const ${exportName} = ${JSON.stringify(transformedRecords, null, 2)} as const;
`;

  // Ensure static records directory exists then write data
  fs.mkdirSync(path.dirname(outputPath), { recursive: true });
  fs.writeFileSync(outputPath, fileContent);
  console.log(`âœ… ${exportName} data written to ${outputPath}`);
};

const Main = async () => {
  const modelName = process.argv[2];
  if (!modelName) {
    console.error('ðŸ’” Please provide a model name as an argument.');
    process.exit(1);
  }

  console.log(`ðŸŒ± Starting the seed process for model: ${modelName}...`);

  const dataDirPath = path.join(__dirname, 'data');
  const dataFiles = fs.readdirSync(dataDirPath);

  const fileMap = new Map<string, { fileName: string, data: any }>();
  for (const fileName of dataFiles) {
    const filePath = path.join(dataDirPath, fileName);
    const { data } = require(filePath);
    fileMap.set(data.modelName, { fileName, data });
  }

  const getDependencies = (model: string, processed = new Set<string>()): string[] => {
    if (processed.has(model)) {
      return [];
    }
    processed.add(model);

    const fileData = fileMap.get(model);
    if (!fileData || !fileData.data.dependencies) {
      return [model];
    }

    const deps = fileData.data.dependencies.flatMap((dep: string) => getDependencies(dep, processed));
    return [...deps, model];
  };

  const modelFileName = `${modelName}.ts`;
  const modelFileData = Array.from(fileMap.values()).find(f => f.fileName === modelFileName);

  if (!modelFileData) {
    console.error(`ðŸ’” Data file for model ${modelName} not found.`);
    process.exit(1);
  }

  const allModelsToProcess = getDependencies(modelFileData.data.modelName);

  for (const modelToProcess of allModelsToProcess) {
    const fileData = fileMap.get(modelToProcess);
    if (fileData) {
      await processFileData(fileData.fileName, fileData.data, !!fileData.data.dependency);
    }
  }
};

// Execute the main function
Main()
  .catch((error) => {
    console.error('ðŸ’” An error occurred during initialization:', error);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
    console.log('ðŸŽ‰ Initialization process finished.');
  });
